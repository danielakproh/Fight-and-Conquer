# class `MapDisplay`

## Purpose

Takes in a noise map generated by [MapGenerator]() and turns it into a texture then applies that texture to a plane GameObject.

## Definition

```csharp
    public class MapDisplay : MonoBehaviour {}
```

 
## Parameters

<table>
<!-- head -->
  <tr style="text-align: center">
    <td><h3>Parameter<h3></td>
    <td><h3>Type<h3></td>
    <td><h3>Description</h3></td>
  </tr>

  <tr>
    <td><code>noiseMap</code></td>
    <td><code>float[,]</code></td>
    <td>A 2-Dimensional array containing noise values comprised between 0 and 1.</td>
  </tr>
</table>

<br>

<!-- Return value  -->
## Returns
**Null**

## Implementation
```csharp
    public class MapDisplay : MonoBehaviour
{
    public Renderer textureRenderer;

    public void DrawNoiseMap(float[,] noiseMap) {
        int width = noiseMap.GetLength(0);
        int height = noiseMap.GetLength(1);

        Texture2D texture = new Texture2D(width, height);

        // generate color array for each pixel in texture
        Color[] colorMap = new Color[width * height];
        
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                colorMap[y * width + x] = Color.Lerp(Color.black, Color.white, noiseMap[x, y]);
            }
        }
        texture.SetPixels(colorMap);
        texture.Apply();

        // allows generation without always having to enter game mode
        textureRenderer.sharedMaterial.mainTexture = texture;
        textureRenderer.transform.localScale = new Vector3(width, 1, height);
    }
}
```

## Description

We first begin by retrieving the height and width values of our 2-dimensional float array and use them to instantiate a Texture2D renderer object. We then color each pixel with a color between black & white using [linear interpolation](), and then store those colors in an array. We finish with applying those colors to our texture object using the Unity's [SetPixels()]() method which is more efficient than [SetPixel()]().













